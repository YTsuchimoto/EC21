# -*- coding: utf-8 -*-
"""3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1usas99e-lvo-jD_7TDeg6fCoZ4qklog6
"""

import numpy
import theano
import theano.tensor as T

t = T.dscalar("t")
x1 = 5*T.cos(2*t) - 2
y1 = 5*T.sin(2*t)
x2 = 10*T.cos(t) - 2
y2 = 10*T.sin(t)

# ヘロンの公式
a = T.sqrt(x1**2 + y1**2)
b = T.sqrt(x2**2 + y2**2)
c = T.sqrt((x1-x2)**2 + (y1-y2)**2)
s = (a+b+c)/2
S = T.sqrt(s * (s-a) * (s-b) * (s-c))

# tで微分
dS = T.grad(S, t)

f = theano.function([t], dS)
g = theano.function([t], S)


# 0 から 2*pi をdiv等分して、傾きが0になってそうなところを探す
"""
div = 100000
L = []
for i in range(div):
    if abs(f(np.pi / div * i)) < 0.005:
        L.append(g(np.pi / div * i))
print(len(L)) # どの程度の個数見つかったか確認
print(max(L))
"""
# と思ったけど、これやるんだったら直接探せばいい…？
div = 100000
ans = -1000
for i in range(div):
    ans = max(g((np.pi / div * i)), ans)

"""求める最大値は"""

print(ans)